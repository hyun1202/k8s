# kube proxy
- 쿠버네티스에서 서비스를 만들었을 때 클러스터 IP나 노드 포트로 접근할 수 있게 만들어 실제 조작을 하는 컴포넌트
- 쿠버네티스 클러스터의 노드마다 실행되면서 클러스터 내부 IP로 연결하려는 요청을 적절한 파드로 전달

## 네트워크 관리
### userspace
- 클라이언트에서 서비스의 클러스터 IP를 통해 어떤 요청을 하면 iptables를 거쳐 kube-proxy가 요청을 받는다.
- 서비스의 클러스터 IP는 연결되어야 하는 적절한 파드로 연결
- 파드 하나로의 연결 요청이 실패하면 자동으로 다른 파드에 연결을 재시도
- 이 때 라운드 로빈 방식을 사용
```
노드
--------------------------------------------
| 클라이언트 -> 클러스터 IP(iptables)           |
|               |                          |
|           kube-proxy   <-  kube-apiserver|
------------/---|----\----------------------
        p1     p2     p3
iptables를 거쳐서 kube-proxy가 요청을 받는다.
```
### iptables
- **kube-proxy는 iptables를 관리하는 역할**만 한다.
- 즉, 직접 클라이언트에서 트래픽을 받지 않는다.
- 모든 요청은 iptables를 거쳐 **파드로 직접 전달**된다.
- 파드 하나로의 연결 요청이 실패하면 재시도하지 않음(요청 실패)
```
              kube-apiserver
노드                  |
---------------------|---------------------
|    클라이언트     kubeproxy                |
|          \       /                      |
|         클러스터 IP(iptables)             |
------------/---|----\---------------------
        p1     p2     p3
kube-proxy는 iptables를 관리하는 역할만 한다.
```
### IPVS
- 리눅스 커널에 있는 L4 로드밸런싱 기술로 `Netfilter`에 포함되어있다.
```
              kube-apiserver
노드                  |
---------------------|---------------------
|    클라이언트     kubeproxy                |
|          \       /                      |
|         클러스터 IP(가상 서버)              |
------------/---|----\---------------------
        p1     p2     p3
커널 공간에서 동작하고 데이터 구조를 해시 테이블로 저장한다.
```
- IPVS 모드는 커널 공간에서 동작하고 데이터 구조를 해시 테이블로 저장하므로 iptables 보다 성능이 좋다.
- 많은 로드밸런싱 알고리즘이 있다.
#### 로드밸런싱 알고리즘
- round-robin(rr): 프로세스 사이에 우선순위를 두지 않고 순서와 시간 단위로 CPU 할당
- least connection(lc): 접속 개수가 가장 적은 서버 선택
- dh(destination hashing): 목적지 IP 주소로 해시 값을 계산해 분산할 실제 서버 선택
- sh(source hashing): 출발지 IP 주소로 해시 값을 계산해 분산할 실제 서버 선택
- sed(shortest expected delay): 응답 속도가 가장 빠른 서버 선택
- nq(never queue): sed와 비슷하지만 활성 접속 개수가 0인 서버를 가장 먼저 선택